<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Intake</title>
    <url>/2025/10/16/Intake/</url>
    <content><![CDATA[<h1 id="Intake车教程"><a href="#Intake车教程" class="headerlink" title="Intake车教程"></a>Intake车教程</h1><h2 id="1-任务拆解"><a href="#1-任务拆解" class="headerlink" title="1. 任务拆解"></a>1. 任务拆解</h2><p>这个intake的手动程序涉及的硬件有两个舵机和一个电机，也就是说我们会接触到一个新的硬件servo。<br>在完成任务的过程中可能会遇到的主要问题就是servo的控制，所以本教程的重点就是控制servo。</p>
<h2 id="2-servo的基本控制方式"><a href="#2-servo的基本控制方式" class="headerlink" title="2. servo的基本控制方式"></a>2. servo的基本控制方式</h2><p>我们在本次任务中使用的goBuilda servo有两种模式，普通servo模式和连续旋转servo(crservo)模式。<br>本程序中需要的模式是cr连续旋转模式。</p>
<blockquote>
<p><strong>两种servo模式对比</strong><br>普通舵机模式：<br>在一个角度范围内 set to position，只能来回扫动无法连续旋转<br>连续旋转舵机模式：<br>也通过set to position 控制，但是可以连续旋转</p>
</blockquote>
<span id="more"></span>

<h3 id="2-0-如何把普通舵机模式转变成连续旋转舵机模式"><a href="#2-0-如何把普通舵机模式转变成连续旋转舵机模式" class="headerlink" title="2.0 如何把普通舵机模式转变成连续旋转舵机模式"></a>2.0 如何把普通舵机模式转变成连续旋转舵机模式</h3><p>这个步骤叫做烧录固件，需要用到programmer<br>(虽然使用的是goBuilda舵机,但是在这里我们用REV的programmer，这不会影响舵机的效果)<br>REV的官方文档中有详细的说明：<a href="https://docs.revrobotics.com/rev-crossover-products/servo/srs-programmer/switching-operating-modes">https://docs.revrobotics.com/rev-crossover-products/servo/srs-programmer/switching-operating-modes</a><br>使用REVprogrammer烧录的程序如下：</p>
<ul>
<li>连接servo和programmer<ul>
<li>使用原本连接舵机和hub的杜邦线，注意插线的方向，白线也就是通信线要在左侧S标志的位置。<br><img src="/images/connectprogrammer1.png" alt="\&quot;ConnectProgrammer\&quot;"></li>
</ul>
</li>
<li>烧录固件<ul>
<li>把programmer的开关turn on，把模式开关滑到c(连续模式)。<br>按下并释放 PROGRAM 按钮一次。<br>PROGRAM LED 应闪烁，然后保持稳定，表示成功。</li>
</ul>
</li>
<li>测试<ul>
<li>在cr或servo模式下，按下并释放TEST可以循环两种测试模式<br>第一次按下 - 自动扫描模式<br>第二次按下 - 手动测试模式<br>第三次按下 - 返回默认状态<br><img src="/images/crservotest1.png" alt="\&quot;cr模式手动测试\&quot;"></li>
</ul>
</li>
</ul>
<h3 id="2-1-servo控制的代码实现"><a href="#2-1-servo控制的代码实现" class="headerlink" title="2.1 servo控制的代码实现"></a>2.1 servo控制的代码实现</h3><p>就像前面所说的，我们用setPosition使舵机连续旋转</p>
<ul>
<li>setPosition(1) - 舵机连续向前旋转</li>
<li>setPosition(0) - 舵机连续向后旋转</li>
<li>setPosition(0.5) - 舵机停止</li>
</ul>
<h4 id="2-1-0-一直连续旋转"><a href="#2-1-0-一直连续旋转" class="headerlink" title="2.1.0 一直连续旋转"></a>2.1.0 一直连续旋转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intakeLeft.setPosition(<span class="number">1</span>);</span><br><span class="line">intakeRight.setPosition(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-手柄控制旋转"><a href="#2-1-1-手柄控制旋转" class="headerlink" title="2.1.1 手柄控制旋转"></a>2.1.1 手柄控制旋转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (gamepad1.right_bumper) &#123;</span><br><span class="line">    intakeMotor.setPower(motorInput);</span><br><span class="line">    intakeLeft.setPosition(<span class="number">1</span>);</span><br><span class="line">    intakeRight.setPosition(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (gamepad1.left_bumper) &#123;</span><br><span class="line">    intakeMotor.setPower(-motorInput);</span><br><span class="line">    intakeLeft.setPosition(<span class="number">0</span>);</span><br><span class="line">    intakeRight.setPosition(<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    intakeMotor.setVelocity(<span class="number">0</span>);</span><br><span class="line">    intakeLeft.setPosition(<span class="number">0.5</span>);</span><br><span class="line">    intakeRight.setPosition(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.firstinspires.ftc.teamcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.eventloop.opmode.TeleOp;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.hardware.DcMotorEx;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.hardware.DcMotorSimple;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.hardware.Servo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TeleOp(name = &quot;IntakeTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntakeTest</span> <span class="keyword">extends</span> <span class="title class_">LinearOpMode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DcMotorEx intakeMotor;</span><br><span class="line">    <span class="keyword">private</span> Servo intakeLeft;</span><br><span class="line">    <span class="keyword">private</span> Servo intakeRight;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runOpMode</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">frontLeftMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;leftFrontMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">backLeftMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;leftBackMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">frontRightMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;rightFrontMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">backRightMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;rightBackMotor&quot;</span>);</span><br><span class="line"></span><br><span class="line">        frontLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE);</span><br><span class="line">        backLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE); <span class="comment">// only for this robot (Broken motor)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">motorInput</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        intakeMotor = hardwareMap.get(DcMotorEx.class,<span class="string">&quot;intakeMotor&quot;</span>);</span><br><span class="line">        intakeLeft = hardwareMap.get(Servo.class,<span class="string">&quot;intakeLeft&quot;</span>);</span><br><span class="line">        intakeRight = hardwareMap.get(Servo.class,<span class="string">&quot;intakeRight&quot;</span>);</span><br><span class="line"></span><br><span class="line">        intakeRight.setDirection(Servo.Direction.REVERSE);</span><br><span class="line">        intakeLeft.setDirection(Servo.Direction.FORWARD);</span><br><span class="line"></span><br><span class="line">        intakeMotor.setDirection(DcMotorSimple.Direction.FORWARD);</span><br><span class="line"></span><br><span class="line">        waitForStart();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(opModeIsActive()) &#123;</span><br><span class="line">            intakeMotor.setPower(motorInput);</span><br><span class="line"></span><br><span class="line">            intakeLeft.setPosition(<span class="number">1</span>);</span><br><span class="line">            intakeRight.setPosition(<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> -gamepad1.left_stick_y;</span><br><span class="line">            <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> gamepad1.left_stick_x * <span class="number">1.1</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">rx</span> <span class="operator">=</span> gamepad1.right_stick_x;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">denominator</span> <span class="operator">=</span> Math.max(Math.abs(y) + Math.abs(x) + Math.abs(rx), <span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">frontLeftPower</span> <span class="operator">=</span> (y + x + rx) / denominator;</span><br><span class="line">            <span class="type">double</span> <span class="variable">backLeftPower</span> <span class="operator">=</span> (y - x + rx) / denominator;</span><br><span class="line">            <span class="type">double</span> <span class="variable">frontRightPower</span> <span class="operator">=</span> (y - x - rx) / denominator;</span><br><span class="line">            <span class="type">double</span> <span class="variable">backRightPower</span> <span class="operator">=</span> (y + x - rx) / denominator;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">powerCoefficient</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">            frontLeftMotor.setPower(frontLeftPower * powerCoefficient);</span><br><span class="line">            backLeftMotor.setPower(backLeftPower * powerCoefficient);</span><br><span class="line">            frontRightMotor.setPower(frontRightPower * powerCoefficient);</span><br><span class="line">            backRightMotor.setPower(backRightPower * powerCoefficient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FTC tutorials</category>
      </categories>
  </entry>
  <entry>
    <title>Limelight</title>
    <url>/2025/10/16/Limelight/</url>
    <content><![CDATA[<h1 id="基于limelight-3A的摄像头追踪"><a href="#基于limelight-3A的摄像头追踪" class="headerlink" title="基于limelight 3A的摄像头追踪"></a>基于limelight 3A的摄像头追踪</h1><p><img src="/images/WholeCar.png" alt="\&quot;Whole Car\&quot;"></p>
<h2 id="1-拆解任务"><a href="#1-拆解任务" class="headerlink" title="1.拆解任务"></a>1.拆解任务</h2><p>开始进行这次任务的同学想必已经完成了基于底盘(odometry<br>computer)的摄像头锁定，这次的任务与odometry computer<br>不同的是这次需要使用到limelight摄像头来进行追踪。</p>
<p>相比于只使用底盘来进行锁定，limelight摄像头对于追踪的tag的更换更加方便和灵活，因此这种方式优于底盘驱动的锁定。</p>
<span id="more"></span>


<p>所以如何实现这个锁定呢？</p>
<p>我们可以把它拆成几步：<br>首先，我们需要解决摄像头的问题，需要通过读取摄像头的反馈来确定我们的视觉中心距离摄像头识别到的apriltag有多远（横向）。<br>第二，我们需要处理这个摄像头的信息过滤，确保它只会锁定&#x2F;反馈给我们需要的apriltag的数据而不是同时锁定很多个不同的april tag的数据。<br>第三，我们需要让电机转一个距离，让我们的摄像头能够成功的将apriltag放到视角中心周边。（这个时候需要提到一个死区的概念，即为apriltag距离视角中心的可接受距离，以避免摄像头频繁转动或者抖动）<br>第四，我们需要考虑当摄像头识别不到目标aprilcode的时候让电机不断旋转来寻找april code 的位置。</p>
<p>好了，其实这个就是这么简单，就让我们开始吧。</p>
<h2 id="2-Limelight的基本代码与使用方式"><a href="#2-Limelight的基本代码与使用方式" class="headerlink" title="2.Limelight的基本代码与使用方式"></a>2.Limelight的基本代码与使用方式</h2><p>要完成任务，我们需要了解如何从limelight中获取数据。<br>这个分为两个部分，第一部分是如何从硬件上（limelight本身）设置过滤器和分辨率以及管道。第二部分则是limelight在AS上的代码实现。</p>
<h3 id="2-0-limelight与电机的链接"><a href="#2-0-limelight与电机的链接" class="headerlink" title="2.0 limelight与电机的链接"></a>2.0 limelight与电机的链接</h3><p>固定好limelight摄像头后，使用一根<strong>BtoC</strong>线连接<em>Limelight</em>的C口与<em>Controll<br>Hub</em>的任意一个USB口。<br><img src="/images/LimelightConnect1.png" alt="\&quot;LimelightConnect\&quot;"><br>对于电机，参考麦轮底盘教程的电机链接与configuration 设置<br><img src="/images/CameraMotorLine1.png" alt="\&quot;CameraMotorLine1\&quot;"><br><img src="/images/CameraMotorLine2.png" alt="\&quot;CameraMotorLine2\&quot;"></p>
<h3 id="2-1-limelight的硬件"><a href="#2-1-limelight的硬件" class="headerlink" title="2.1 limelight的硬件"></a>2.1 limelight的硬件</h3><p>现在你可以开始设置limelight的硬件了！<br>使用一根数据线连接limelight摄像头的C口与你的电脑，随后进入这个<a href="%22http://limelight.local:5801%22">http://limelight.local:5801</a>网址，以设置你的limelight。<br>进入之后，选择一个你喜欢的pipeline进行设置。<br>你需要注意的几项有：</p>
<ul>
<li>Input: Exposure(曝光度)<ul>
<li>这一项最好设置在200左右以达到最优性能。</li>
</ul>
</li>
<li>Input: Resolution(分辨率)<ul>
<li>这一项最好设置一个能看的分辨率以及尽量高的帧数，用来提高识别到april<br>code的概率。</li>
</ul>
</li>
<li>Configuration: ID filters(ID过滤器 <em>注意这里是白名单</em>)<ul>
<li>这一项是用来过滤你想要锁定的april tag<br>ID的，如例子中展示，只允许了ID23的april tag被检测。</li>
</ul>
</li>
<li>最后不要忘记按一下左上角的星星保存pipeline<br><img src="/images/LimelightWebpage1.png" alt="\&quot;LimelightWebpage1\&quot;"><br><img src="/images/LimelightWebpage2.png" alt="\&quot;LimelightWebpage2\&quot;"></li>
</ul>
<h3 id="2-2-limelight在AS上的数据读取"><a href="#2-2-limelight在AS上的数据读取" class="headerlink" title="2.2 limelight在AS上的数据读取"></a>2.2 limelight在AS上的数据读取</h3><p>首先我们在AS上调用的话就需要获取摄像头的硬件并为他们进行初始化。这与普通硬件的初始化是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DcMotorEx</span> <span class="variable">cameraMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class, <span class="string">&quot;cameraMotor&quot;</span>);</span><br><span class="line"><span class="type">Limelight3A</span> <span class="variable">limelight</span> <span class="operator">=</span> hardwareMap.get(Limelight3A.class, <span class="string">&quot;camera1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在成功获取硬件道路之后我们可以为其进行更进一步的初始化，包括切换管道，以及开启limelight摄像头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">limelight.pipelineSwitch(<span class="number">7</span>);</span><br><span class="line">limelight.start();</span><br></pre></td></tr></table></figure>

<p>在为他们完成初始化之后就可以通过limelight<br>来使用摄像头的功能以及读取摄像头的返回值了。</p>
<p>在官网上，他们为摄像头配备了很多语句以及他们的用途：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;FiducialResult&gt; fiducials = result.getFiducialResults();</span><br><span class="line"><span class="keyword">for</span> (FiducialResult fiducial : fiducials) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> fiducial.getFiducialId(); <span class="comment">// 基准标记的ID号</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> detection.getTargetXDegrees(); <span class="comment">// 它的位置（左右）</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> detection.getTargetYDegrees(); <span class="comment">// 它的位置（上下）</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">StrafeDistance_3D</span> <span class="operator">=</span> fiducial.getRobotPoseTargetSpace().getY(); </span><br><span class="line">    telemetry.addData(<span class="string">&quot;基准标记 &quot;</span> + id, <span class="string">&quot;距离 &quot;</span> + distance + <span class="string">&quot; 米&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fiducial.getRobotPoseTargetSpace(); <span class="comment">// 相对于AprilTag坐标系的机器人姿态（最有用）</span></span><br><span class="line">fiducial.getCameraPoseTargetSpace(); <span class="comment">// 相对于AprilTag的相机姿态（有用）</span></span><br><span class="line">fiducial.getRobotPoseFieldSpace(); <span class="comment">// 仅基于此标签的场地坐标系中的机器人姿态（有用）</span></span><br><span class="line">fiducial.getTargetPoseCameraSpace(); <span class="comment">// 相机坐标系中的AprilTag姿态（不太有用）</span></span><br><span class="line">fiducial.getTargetPoseRobotSpace(); <span class="comment">// 机器人坐标系中的AprilTag姿态（不太有用）</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.limelightvision.io/zh/docs/docs-limelight/apis/ftc-programming">官网地址</a><br>这是针对april tag的部分的大致代码。<br>但是实际上我们需要用到的语句只有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fiducial.getTargetXDegrees();</span><br></pre></td></tr></table></figure>

<p>因为我们几乎只需要使用这句话来对我们想要锁定的目标的横向的偏移量进行测量。<br>在我们的代码中我们把这部分写成了这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LLResult</span> <span class="variable">result</span> <span class="operator">=</span> limelight.getLatestResult();</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.isValid() &amp;&amp; !result.getFiducialResults().isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (LLResultTypes.FiducialResult tag : result.getFiducialResults()) &#123;</span><br></pre></td></tr></table></figure>

<p>同时我们对于fiducial ID<br>的检测和筛选已经在硬件部分完成了，因此不需要再次判断是否为我们想要锁定的april<br>code。我们可以直接基于这个tx来给电机进行功率输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">txRaw</span> <span class="operator">=</span> tag.getTargetXDegrees();</span><br></pre></td></tr></table></figure>

<p>如果需要驱动telemetry来进行调试，也可以调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">telemetry.addData(<span class="string">&quot;TagID&quot;</span>, tag.getFiducialId());</span><br><span class="line">telemetry.addData(<span class="string">&quot;txRaw&quot;</span>, txRaw);</span><br><span class="line">telemetry.addData(<span class="string">&quot;txFiltered&quot;</span>, txFiltered);</span><br><span class="line">telemetry.addData(<span class="string">&quot;ty&quot;</span>, tag.getTargetYDegrees());</span><br></pre></td></tr></table></figure>

<p>至于为什么fiducals是一个数组，是因为原本limelight是为了<strong>同时识别很多个目标</strong>做的，因此会得到<strong>很多组数据</strong>。而我们<strong>只需要锁定一个</strong>数据并且<strong>已经在硬件层面进行过过滤</strong>了所以并不需要担心循环中出现其他的tag，直接在循环内执行代码就行。</p>
<p>需要注意的是，这些语句只能针对fiducals<strong>数组中的元素</strong>才能调用，当针对整个数组时是无法调用的。</p>
<p>还需要注意的是tx给出的返回值是一个<strong>角度（角度制）</strong>。</p>
<h2 id="3-如何驱动电机"><a href="#3-如何驱动电机" class="headerlink" title="3.如何驱动电机"></a>3.如何驱动电机</h2><p>得到来自摄像头的对于april code<br>的偏移角度之后就可以通过计算一个简化版的PID调试来控制电机的旋转功率来让我们的摄像头对准april<br>code。<br>这里需要注意的是我们一定需要设定一个死区<code>double deadband = 7.0;</code>来确保摄像头不会过于敏感。这个死区大概位于5-10度之间是较为合适的。如果没有死区或者死区太小会导致摄像头（电机）的摆动，因此需要死区来限制最小调整范围以确保摆动被尽可能限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">kP</span> <span class="operator">=</span> <span class="number">0.01</span>; <span class="comment">// 减少幅度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">power</span> <span class="operator">=</span> kP * txFiltered;</span><br><span class="line">power = Math.max(-<span class="number">0.15</span>, Math.min(<span class="number">0.15</span>, power));</span><br><span class="line">cameraMotor.setPower(power);</span><br></pre></td></tr></table></figure>

<p>接下来，你会发现如果不给摄像头设置一个默认值（当april<br>code仍然在死区内时），摄像头会一直转动一直到摄像头达到死区的另外一边，并开始反过来转动，循环往复。<br>这个时候我们就需要给代码加上分类处理，处理当摄像头存在于死区之内的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cameraMotor.setPower(<span class="number">0</span>);</span><br><span class="line">telemetry.addLine(<span class="string">&quot;Aligned (within deadband)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>把这两个合起来长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">deadband</span> <span class="operator">=</span> <span class="number">7.0</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(txFiltered) &gt; deadband) &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">kP</span> <span class="operator">=</span> <span class="number">0.01</span>; <span class="comment">// 减少幅度</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">power</span> <span class="operator">=</span> kP * txFiltered;</span><br><span class="line">    power = Math.max(-<span class="number">0.15</span>, Math.min(<span class="number">0.15</span>, power));</span><br><span class="line">    cameraMotor.setPower(power);</span><br><span class="line">    telemetry.addData(<span class="string">&quot;MotorPower&quot;</span>, power);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cameraMotor.setPower(<span class="number">0</span>);</span><br><span class="line">    telemetry.addLine(<span class="string">&quot;Aligned (within deadband)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子就完成了对于tx的大致处理，你的摄像头已经可以大概对准你设定的april<br>code了。</p>
<p>如果想要更加稳定的摄像头，或者彻底消除初步代码带来的波动，请移步<a href="#41%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2">高斯滤波</a>。</p>
<p>当然，你会问另一个问题，”如果我的摄像头没有在一开始就对准april code<br>或者我的摄像头后面丢失目标了怎么办？”<br>很好，这就引导我们解决另外一个情况，即为待机状态，或者寻找状态（我更喜欢叫他哨戒状态）。<br>这部分也很简单，只需要通过调用在limelight摄像头的这些函数就可以实现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LLResult</span> <span class="variable">result</span> <span class="operator">=</span> limelight.getLatestResult();</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.isValid() &amp;&amp; !result.getFiducialResults().isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (LLResultTypes.FiducialResult tag : result.getFiducialResults()) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">txRaw</span> <span class="operator">=</span> tag.getTargetXDegrees();</span><br></pre></td></tr></table></figure>

<p>这一部分中的if()即可判断摄像头在这一刻是否检测到了数据，如果有，那么可以进入上面的部分进行追踪，如果没有，就可以进入哨戒状态，<strong>通过慢速的，不断的旋转电机</strong>来在车体周围寻找目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">lostPower</span> <span class="operator">=</span> <span class="number">0.13</span>; <span class="comment">// 用小功率找</span></span><br><span class="line">cameraMotor.setPower(lostPower);</span><br></pre></td></tr></table></figure>

<p><a href="#42%E4%B8%A2%E5%A4%B1%E7%9B%AE%E6%A0%87%E5%AF%BB%E6%89%BE%E5%93%A8%E6%88%92%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96">更优的哨戒模式</a>可以在这里查看。</p>
<p>到这里，恭喜你，你就完成了通过摄像头返回的tx值来驱动电机锁定目标的大致框架。剩下的工作就只剩下了调试和优化你写出来的框架以及接入麦轮底盘代码进行遥控测试。</p>
<h2 id="4-调试和优化"><a href="#4-调试和优化" class="headerlink" title="4.调试和优化"></a>4.调试和优化</h2><h3 id="4-1高斯滤波"><a href="#4-1高斯滤波" class="headerlink" title="4.1高斯滤波"></a>4.1高斯滤波</h3><h3 id="4-2丢失目标寻找（哨戒模式）优化"><a href="#4-2丢失目标寻找（哨戒模式）优化" class="headerlink" title="4.2丢失目标寻找（哨戒模式）优化"></a>4.2丢失目标寻找（哨戒模式）优化</h3><p>很好，相信到这里你的大部分代码已经写完了，现在我们来解决车体在旋转时丢失目标后如何优化寻找效率。当然对于普通的移动丢失目标也适用。<br>首先，在正常情况下，我们的车体在丢失目标之后都会进入哨戒模式，正向旋转一整圈寻找丢失的目标。有的时候这很管用，如果目标正好在左边。但是如果目标在右面呢？直接把输出功率乘以-1让电机反向旋转吗？<br>不，这样子会导致摄像头寻找从左边丢失的目标的时间加长，同时还非常不美观，必须舍弃一边来获取另一边的效率。<br>相信看到这里各位都想到了解决的方式，那就是<strong>通过记录最后一次看到目标tag的tx来确定目标是从左边消失的还是从右边消失的，进而来确定电机应该往哪个方向旋转。</strong><br>这样子处理的话可以大大减少电机的旋转时间，从而减少丢失目标的时间，是一项十分有用的优化。<br>可以从最开始的只要钻转就会丢失目标进化到全速旋转也不会丢失目标。</p>
<p>实现思路是这样的：<br>首先设立一个循环外变量，<code>lastTx</code>。<br>让这个变量等于每次获取到april code<br>之后的tx值。<em>注意，对于这个变量，tx值的内容并不重要，重要的是tx值的正负。其实完全可以使用bool类型来做变量但是我为了调试方便还是选择了double</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Double</span> <span class="variable">lastTx</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runOpMode</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//skip for now</span></span><br><span class="line">        <span class="keyword">while</span> (opModeIsActive()) &#123;</span><br><span class="line">            <span class="type">LLResult</span> <span class="variable">result</span> <span class="operator">=</span> limelight.getLatestResult();</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.isValid() &amp;&amp; !result.getFiducialResults().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (LLResultTypes.FiducialResult tag : result.getFiducialResults()) &#123;</span><br><span class="line">                    lastTx = txRaw; <span class="comment">// 更新最后一次检测到的tx</span></span><br></pre></td></tr></table></figure>

<p>然后，在进入哨戒模式时，检测这个<code>lastTx</code>,判断其的正负，来确定电机旋转的方向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//根据 lastTx 决定方向</span></span><br><span class="line">    <span class="keyword">if</span> (lastTx != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">lostPower</span> <span class="operator">=</span> <span class="number">0.13</span>; <span class="comment">// 用小功率找</span></span><br><span class="line">        <span class="keyword">if</span> (lastTx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//最后在右边往左转</span></span><br><span class="line">            cameraMotor.setPower(lostPower); <span class="comment">//控制电机向左去找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//最后在左边往右转</span></span><br><span class="line">            cameraMotor.setPower(-lostPower); <span class="comment">//控制电机向右去找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cameraMotor.setPower(<span class="number">0.15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在找到april<br>code后，代码退出哨戒模式重新返回锁定模式，再次开始更新<code>lastTx</code>。</p>
<h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5.完整代码"></a>5.完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.firstinspires.ftc.teamcode;</span><br><span class="line"><span class="comment">//在cyz发的limelight111版本的基础上加了lasttx，用来判断丢失时云台转的方向</span></span><br><span class="line"><span class="keyword">import</span> com.qualcomm.hardware.limelightvision.LLResult;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.hardware.limelightvision.Limelight3A;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.hardware.limelightvision.LLResultTypes;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.eventloop.opmode.TeleOp;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.hardware.DcMotorEx;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.hardware.DcMotorSimple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TeleOp(name = &quot;Limelighttest1112&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">limelight1112</span> <span class="keyword">extends</span> <span class="title class_">LinearOpMode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Limelight3A limelight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WINDOW_SIZE</span> <span class="operator">=</span> <span class="number">6</span>;  <span class="comment">// 高斯窗口增大一点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Double&gt; txHistory = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Double</span> <span class="variable">lastTx</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 上一次检测到的tx</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lostcount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高斯权重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span>[] gaussianKernel = &#123;<span class="number">0.06136</span>, <span class="number">0.24477</span>, <span class="number">0.38774</span>, <span class="number">0.24477</span>, <span class="number">0.06136</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">previousTxFiltered</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 搞一个低通滤波器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runOpMode</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">cameraMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class, <span class="string">&quot;cameraMotor&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cameraMotor.setMode(DcMotorEx.RunMode.RUN_WITHOUT_ENCODER);</span><br><span class="line"></span><br><span class="line">        limelight = hardwareMap.get(Limelight3A.class, <span class="string">&quot;camera1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        telemetry.setMsTransmissionInterval(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        limelight.pipelineSwitch(<span class="number">7</span>);</span><br><span class="line">        limelight.start();</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">frontLeftMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;leftFrontMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">backLeftMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;leftBackMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">frontRightMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;rightFrontMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">backRightMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;rightBackMotor&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reverse the right side motors. This may be wrong for your setup.</span></span><br><span class="line">        <span class="comment">// If your robot moves backwards when commanded to go forwards,</span></span><br><span class="line">        <span class="comment">// reverse the left side instead.</span></span><br><span class="line">        <span class="comment">// See the note about this earlier on this page.[]\</span></span><br><span class="line">        frontRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);</span><br><span class="line">        backRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);</span><br><span class="line"></span><br><span class="line">        waitForStart();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">notfound</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (opModeIsActive()) &#123;</span><br><span class="line">            <span class="type">LLResult</span> <span class="variable">result</span> <span class="operator">=</span> limelight.getLatestResult();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.isValid() &amp;&amp; !result.getFiducialResults().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (LLResultTypes.FiducialResult tag : result.getFiducialResults()) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">txRaw</span> <span class="operator">=</span> tag.getTargetXDegrees();</span><br><span class="line">                    lastTx = txRaw; <span class="comment">// 更新最后一次检测到的tx</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (txHistory.size() &gt;= WINDOW_SIZE) txHistory.poll();</span><br><span class="line">                    txHistory.add(txRaw);</span><br><span class="line"></span><br><span class="line">                    <span class="type">double</span> <span class="variable">txFiltered</span> <span class="operator">=</span> applyGaussianFilter();</span><br><span class="line">                    txFiltered = applyLowPassFilter(txFiltered);</span><br><span class="line"></span><br><span class="line">                    <span class="type">double</span> <span class="variable">deadband</span> <span class="operator">=</span> <span class="number">7.0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(txFiltered) &gt; deadband) &#123;</span><br><span class="line">                        <span class="type">double</span> <span class="variable">kP</span> <span class="operator">=</span> <span class="number">0.01</span>; <span class="comment">// 减少幅度</span></span><br><span class="line">                        <span class="type">double</span> <span class="variable">power</span> <span class="operator">=</span> kP * txFiltered;</span><br><span class="line">                        power = Math.max(-<span class="number">0.15</span>, Math.min(<span class="number">0.15</span>, power));</span><br><span class="line">                        cameraMotor.setPower(power);</span><br><span class="line">                        telemetry.addData(<span class="string">&quot;MotorPower&quot;</span>, power);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cameraMotor.setPower(<span class="number">0</span>);</span><br><span class="line">                        telemetry.addLine(<span class="string">&quot;Aligned (within deadband)&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    telemetry.addData(<span class="string">&quot;TagID&quot;</span>, tag.getFiducialId());</span><br><span class="line">                    telemetry.addData(<span class="string">&quot;txRaw&quot;</span>, txRaw);</span><br><span class="line">                    telemetry.addData(<span class="string">&quot;txFiltered&quot;</span>, txFiltered);</span><br><span class="line">                    telemetry.addData(<span class="string">&quot;ty&quot;</span>, tag.getTargetYDegrees());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//根据 lastTx 决定方向</span></span><br><span class="line">                <span class="keyword">if</span> (lastTx != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">lostPower</span> <span class="operator">=</span> <span class="number">0.13</span>; <span class="comment">// 用小功率找</span></span><br><span class="line">                    <span class="keyword">if</span> (lastTx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//最后在右边往左转</span></span><br><span class="line">                        cameraMotor.setPower(lostPower);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//最后在左边往右转</span></span><br><span class="line">                        cameraMotor.setPower(-lostPower);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cameraMotor.setPower(<span class="number">0.15</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            telemetry.update();</span><br><span class="line">            <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> -gamepad1.left_stick_y; <span class="comment">// Remember, Y stick value is reversed</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> gamepad1.left_stick_x * <span class="number">1.1</span>; <span class="comment">// Counteract imperfect strafing</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">rx</span> <span class="operator">=</span> gamepad1.right_stick_x;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Denominator is the largest motor power (absolute value) or 1</span></span><br><span class="line">            <span class="comment">// This ensures all the powers maintain the same ratio,</span></span><br><span class="line">            <span class="comment">// but only if at least one is out of the range [-1, 1]</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">denominator</span> <span class="operator">=</span> Math.max(Math.abs(y) + Math.abs(x) + Math.abs(rx), <span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">frontLeftPower</span> <span class="operator">=</span> (y + x + rx) / denominator;</span><br><span class="line">            <span class="type">double</span> <span class="variable">backLeftPower</span> <span class="operator">=</span> (y - x + rx) / denominator;</span><br><span class="line">            <span class="type">double</span> <span class="variable">frontRightPower</span> <span class="operator">=</span> (y - x - rx) / denominator;</span><br><span class="line">            <span class="type">double</span> <span class="variable">backRightPower</span> <span class="operator">=</span> (y + x - rx) / denominator;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> powerCoefficent= <span class="number">0.6</span>;</span><br><span class="line"></span><br><span class="line">            frontLeftMotor.setPower(frontLeftPower*powerCoefficent);</span><br><span class="line">            backLeftMotor.setPower(backLeftPower*powerCoefficent);</span><br><span class="line">            frontRightMotor.setPower(frontRightPower*powerCoefficent);</span><br><span class="line">            backRightMotor.setPower(backRightPower*powerCoefficent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">applyGaussianFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (txHistory.isEmpty()) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        Double[] values = txHistory.toArray(<span class="keyword">new</span> <span class="title class_">Double</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 权重对齐到最新值（右端）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">kernelIndex</span> <span class="operator">=</span> gaussianKernel.length - size + i;</span><br><span class="line">            <span class="keyword">if</span> (kernelIndex &lt; <span class="number">0</span>) kernelIndex = <span class="number">0</span>;</span><br><span class="line">            sum += values[i] * gaussianKernel[kernelIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">applyLowPassFilter</span><span class="params">(<span class="type">double</span> currentTxFiltered)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">alpha</span> <span class="operator">=</span> <span class="number">0.1</span>;  <span class="comment">// 平滑系数，值越小越平滑</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">filtered</span> <span class="operator">=</span> alpha * currentTxFiltered + (<span class="number">1</span> - alpha) * previousTxFiltered;</span><br><span class="line">        previousTxFiltered = filtered;</span><br><span class="line">        <span class="keyword">return</span> filtered;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作者：檀若之，陈奕卓，忻鹿, 周泊君</span></span><br><span class="line"><span class="comment">//时间：Sep 28, 2025</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>神秘生物图鉴</strong><br><img src="/images/%E7%A5%9E%E7%A7%98%E7%94%9F%E7%89%A9.png" alt="\&quot;LimelightWebpage1\&quot;"></p>
</blockquote>
<p><em><strong>作者：忻鹿</strong></em><br><em><strong>Sep 28, 2025</strong></em><br>:::</p>
]]></content>
      <categories>
        <category>FTC tutorials</category>
      </categories>
  </entry>
  <entry>
    <title>MecanumDrive</title>
    <url>/2025/10/16/MecanumChasis/</url>
    <content><![CDATA[<h1 id="麦轮底盘教程"><a href="#麦轮底盘教程" class="headerlink" title="麦轮底盘教程"></a>麦轮底盘教程</h1><p>首先可以大部分参考这个官方教程:<br><a href="https://gm0.org/zh-cn/latest/docs/software/tutorials/mecanum-drive.html">https://gm0.org/zh-cn/latest/docs/software/tutorials/mecanum-drive.html</a><br>下面我对官方教程做一些补充说明</p>
<h2 id="1-如何推导出⻨克纳姆轮的不同移动⽅式"><a href="#1-如何推导出⻨克纳姆轮的不同移动⽅式" class="headerlink" title="1. 如何推导出⻨克纳姆轮的不同移动⽅式"></a>1. 如何推导出⻨克纳姆轮的不同移动⽅式</h2><p>简而言之，每个麦轮会有一个斜向的实际作用力，我们可以把它分解成竖直和水平方向的两个分力，并且通过力的合成实现不同移动。</p>
<span id="more"></span>

<p><img src="/images/MecanumDrive.png" alt="\&quot;MecanumDrive\&quot;"><br><img src="/images/Chasis.png" alt="\&quot;Chasis\&quot;"><br>下图是电机全部为正值时(向前转)的⻨轮的⼒和向量。当电机为负值时(向后转)，⻨轮的⼒和向量都与左图中的呈中⼼对称。</p>
<h2 id="2-底盘-demo-⽰例"><a href="#2-底盘-demo-⽰例" class="headerlink" title="2. 底盘 demo ⽰例"></a>2. 底盘 demo ⽰例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.firstinspires.ftc.teamcode; <span class="comment">//定义这个class所在的包名，如果把程序放在其他包下，包名不对应就会报错</span></span><br><span class="line"><span class="comment">//写自己的代码时都会在teamcode这个package中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.eventloop.opmode.TeleOp;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.hardware.DcMotor;</span><br><span class="line"><span class="keyword">import</span> com.qualcomm.robotcore.hardware.DcMotorEx;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TeleOp(name=&quot;Chasis&quot;)</span> <span class="comment">//一定要写name，这样你的程序才能出现在 driver hub 的列表中</span></span><br><span class="line"><span class="comment">//@TeleOp的意思是声明这个程序是一个手动控制程序，相应地 @Autonomous 是声明这是一个自动程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chasis</span> <span class="keyword">extends</span> <span class="title class_">LinearOpMode</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写方法，让程序按照下面重写的执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runOpMode</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//链接硬件的方法，&quot;&quot;里的硬件名称需要与 driver hub 里的config一致，注意要统一所有人的config</span></span><br><span class="line">        <span class="comment">//DcMotorEx是DcMotor的扩展，两种任选其一</span></span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">frontLeftMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;leftFrontMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">backLeftMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;leftBackMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">frontRightMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;rightFrontMotor&quot;</span>);</span><br><span class="line">        <span class="type">DcMotorEx</span> <span class="variable">backRightMotor</span> <span class="operator">=</span> hardwareMap.get(DcMotorEx.class,<span class="string">&quot;rightBackMotor&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//底盘安装电机时左右两侧是镜像的，setDirection设置右侧电机反转</span></span><br><span class="line">        frontRightMotor.setDirection(DcMotor.Direction.REVERSE);</span><br><span class="line">        backRightMotor.setDirection(DcMotor.Direction.REVERSE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//程序停在wait for start, driver hub显示init，启动程序需要点击init再点开始</span></span><br><span class="line">        <span class="comment">//完成初始化后，让车不会乱动</span></span><br><span class="line">        </span><br><span class="line">        waitForStart();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (opModeIsActive())&#123;</span><br><span class="line">            <span class="comment">//程序启动后获取手柄左右两个摇杆的数值</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> gamepad1.left_stick_x; <span class="comment">//左摇杆x值控制车左右平移</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> -gamepad1.left_stick_y; <span class="comment">//左摇杆y值控制车前后平移</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">rx</span> <span class="operator">=</span> -gamepad1.right_stick_x; <span class="comment">//右摇杆x值控制旋转</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//max(最大电机功率绝对值,1)，意思是当电机功率超过（-1,1）的范围时要取最大电机功率绝对值作为一个分母</span></span><br><span class="line">            <span class="comment">//当超过范围时要把四个电机功率都除以这个分母a，使最大的电机功率为1，所有轮子的功率满足原本的比例关系</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Math.max(Math.abs(x)+ Math.abs(y)+ Math.abs(rx), <span class="number">1</span>); </span><br><span class="line">          </span><br><span class="line">            <span class="comment">//不在这里写详细的推导，举一个简化例子</span></span><br><span class="line">            <span class="comment">//当希望车向左前方平移，左摇杆向左前方推，这时x=-1，y=1，右摇杆不动</span></span><br><span class="line">            <span class="comment">//frontLeftMotor的功率是y + x + rx=0</span></span><br><span class="line">            <span class="comment">//backLeftMotor的功率是y-x+rx=2</span></span><br><span class="line">            <span class="comment">//frontRightMotor的功率是y-x-rx=2</span></span><br><span class="line">            <span class="comment">//backRightMotor的功率是y+x-rx=0</span></span><br><span class="line">            <span class="comment">//正好符合上面图中的方式</span></span><br><span class="line">            frontLeftMotor.setPower((y + x + rx) / a);</span><br><span class="line">            backLeftMotor.setPower((y-x+rx)/a);</span><br><span class="line">            frontRightMotor.setPower((y-x-rx)/a);</span><br><span class="line">            backRightMotor.setPower((y+x-rx)/a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>在driver hub的手机上测试，手机要链接车的WiFi。<br>在dirver hub里写好config，麦轮底盘用到了control hub 和expansion hub，在确定接口的时候可以顺着每个电机的线找到相应的hub和接口，编辑好config后点击 activate。</p>
<blockquote>
<p><strong>Tip</strong><br>多人协作时要统一硬件映射名称，共同使用一个config</p>
</blockquote>
<p>用CtoA数据线连接电脑和control hub，注意电脑不要连车的WiFi，AS的顶栏会有一个刷新的图标，点击之后传输程序，传程序之前要写程序的name。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TeleOp(name=&quot;Chasis&quot;)</span> </span><br></pre></td></tr></table></figure>
<p>传输好之后在driver hub右侧的倒三角（右侧是TeleOp手动程序）选你自己的程序，把手柄连接到手机上。<br>第一次启动手柄时按start和x键，手柄震动表示链接成功。
            
          </p>
]]></content>
      <categories>
        <category>FTC tutorials</category>
      </categories>
  </entry>
</search>
